import { component$, useContext, useTask$, useSignal } from "@builder.io/qwik";
import { TaxationContext } from "../contexts/taxation-context";
import { TaxationStrategyVisualization } from "./taxation-strategy-visualization-new";
import "./taxation-strategy-comparison.css";

export const TaxationStrategyComparison = component$(() => {
  // Get the taxation context
  const taxationState = useContext(TaxationContext);

  // Get all taxation models
  const models = taxationState.taxationModels;

  // Create a signal to store the revenue comparison data
  const revenueComparison = useSignal<any[]>([]);

  // Use a task to call the QRL function and update the signal
  useTask$(async () => {
    try {
      // Call the QRL function
      const result = await taxationState.getTaxRevenueComparison();

      // Update the signal with the result (ensure it's an array)
      revenueComparison.value = Array.isArray(result) ? result : [];
    } catch (error) {
      console.error("Error getting tax revenue comparison:", error);
      revenueComparison.value = [];
    }
  });

  // Find the strategy with the highest revenue
  const maxRevenue =
    revenueComparison.value.length > 0
      ? Math.max(...revenueComparison.value.map((item) => item.revenue))
      : 0;

  return (
    <div class="taxation-strategy-comparison">
      <h2 class="comparison-title">Taxation Strategy Comparison</h2>

      <div class="revenue-comparison">
        <h3>Tax Revenue Comparison</h3>
        <div class="revenue-bars">
          {revenueComparison.value.map((item) => (
            <div key={item.name} class="revenue-bar-container">
              <div class="revenue-label">{item.name}</div>
              <div class="revenue-bar-wrapper">
                <div
                  class="revenue-bar"
                  style={{
                    height: `${(item.revenue / maxRevenue) * 100}%`,
                    backgroundColor: getStrategyColor(item.name),
                  }}
                ></div>
              </div>
              <div class="revenue-value">{item.formattedRevenue}</div>
            </div>
          ))}
        </div>
        <p class="revenue-note">
          Tax revenue generated by each model based on the current UBI
          parameters. The Bell Curve model generates the most revenue.
        </p>
      </div>

      <div class="strategy-visualizations">
        {models.map((model) => (
          <TaxationStrategyVisualization key={model.name} model={model} />
        ))}
      </div>

      <div class="comparison-summary">
        <h3>Key Findings</h3>
        <ul>
          <li>
            <strong>Bell Curve Model:</strong> Generates the most tax revenue by
            optimizing the tax burden distribution.
          </li>
          <li>
            <strong>Progressive Tax Model:</strong> More equitable than Flat Tax
            but generates less revenue than Bell Curve.
          </li>
          <li>
            <strong>Flat Tax Model:</strong> Simplest to implement but less
            efficient for revenue generation.
          </li>
          <li>
            The Bell Curve model's efficiency comes from targeting the "sweet
            spot" for taxation - upper-middle to high incomes where there's
            substantial income but less tax avoidance.
          </li>
        </ul>
      </div>
    </div>
  );
});

/**
 * Format currency for display
 */
function formatCurrency(amount: number): string {
  return "$" + Math.round(amount).toLocaleString();
}

/**
 * Get a color for each strategy
 */
function getStrategyColor(strategyName: string): string {
  switch (strategyName) {
    case "Flat Tax":
      return "#3b82f6"; // Blue
    case "Progressive Tax":
      return "#8b5cf6"; // Purple
    case "Bell Curve":
      return "#10b981"; // Green
    default:
      return "#6b7280"; // Gray
  }
}
